#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// --- ПРОТОТИПИ ФУНКЦІЙ ---

// Робота з пам'яттю
int** create_matrix(int rows, int cols);  // Прототип функції для створення матриці
void free_matrix(int** matrix, int rows);  // Прототип функції для звільнення пам'яті

// Заповнення та вивід
void fill_matrix_random(int** matrix, int rows, int cols);  // Прототип для заповнення матриці випадковими числами
void fill_matrix_user(int** matrix, int rows, int cols);  // Прототип для заповнення матриці вручну
void print_matrix(int** matrix, int rows, int cols, const char* name);  // Прототип для виведення матриці на екран

// Завдання лабораторної
void task_max_min_diagonal(int** A, int n_a, int variant);  // Прототип для пошуку максимальних і мінімальних елементів відносно діагоналі
int** task_transpose_b(int** B, int rows, int cols);  // Прототип для транспонування матриці
int** task_multiply_matrices(int** A, int rows_a, int cols_a, int** B, int rows_b, int cols_b);  // Прототип для множення матриць
void task_sort_rows(int** A, int rows, int cols);  // Прототип для сортування рядків матриці
void task_calc_sums(int** A, int rows_a, int cols_a, int** B, int rows_b, int cols_b);  // Прототип для обчислення сум елементів

// --- ГОЛОВНА ФУНКЦІЯ ---
int main() {
    srand(time(NULL));  // Ініціалізація генератора випадкових чисел
    int **MatrixA = NULL;  // Вказівник на першу матрицю A
    int **MatrixB = NULL;  // Вказівник на другу матрицю B
    int **MatrixResult = NULL;  // Вказівник на результат виконання операцій (множення, транспонування тощо)
    
    int Na, Nb, Mb;  // Розміри матриць
    int variant;  // Змінна для вибору варіанту завдання
    int choice;  // Змінна для вибору операції з меню

    // Введення параметрів
    printf("Enter your variant number: ");
    scanf("%d", &variant);  // Вводимо номер варіанту для завдання

    printf("Enter size for Matrix A (Na x Na): ");
    scanf("%d", &Na);  // Вводимо розмір першої матриці (квадратна матриця)

    printf("Enter rows for Matrix B (Nb): ");
    scanf("%d", &Nb);  // Вводимо кількість рядків для другої матриці

    printf("Enter cols for Matrix B (Mb): ");
    scanf("%d", &Mb);  // Вводимо кількість стовпців для другої матриці

    // 1. Виділення пам'яті
    MatrixA = create_matrix(Na, Na);  // Виділяємо пам'ять для матриці A
    MatrixB = create_matrix(Nb, Mb);  // Виділяємо пам'ять для матриці B

    // Перевірка успішності виділення пам'яті
    if (!MatrixA || !MatrixB) {
        printf("Memory allocation failed!\n");
        return 1;  // Якщо пам'ять не вдалося виділити, вивести помилку і завершити програму
    }

    // Початкове заповнення
    printf("\n--- Filling Matrix A ---\n");
    // Можна замінити на fill_matrix_user для ручного введення
    fill_matrix_random(MatrixA, Na, Na);  // Заповнюємо матрицю A випадковими числами
    
    printf("\n--- Filling Matrix B ---\n");
    fill_matrix_random(MatrixB, Nb, Mb);  // Заповнюємо матрицю B випадковими числами

    // Головне меню
    do {
        printf("\n\n=== MENU ===\n");
        printf("1. Show Matrices\n");  // Вивести матриці
        printf("2. Find Max/Min relative to diagonal (Task 1)\n");  // Завдання 1: Макс/мін відносно діагоналі
        printf("3. Transpose Matrix B (Task 2)\n");  // Завдання 2: Транспонування
        printf("4. Multiply A * B (Task 3)\n");  // Завдання 3: Множення матриць
        printf("5. Sort Matrix A rows (Task 4)\n");  // Завдання 4: Сортування рядків матриці A
        printf("6. Calculate Sums (Task 5)\n");  // Завдання 5: Суми рядків і стовпців
        printf("0. Exit\n");  // Вихід
        printf("Choice: ");
        scanf("%d", &choice);  // Вводимо вибір операції

        switch (choice) {  // Вибір операції
            case 1:
                print_matrix(MatrixA, Na, Na, "A");  // Виводимо матрицю A
                print_matrix(MatrixB, Nb, Mb, "B");  // Виводимо матрицю B
                break;
            case 2:
                task_max_min_diagonal(MatrixA, Na, variant);  // Завдання 1: Макс/мін відносно діагоналі
                break;
            case 3:
                if (MatrixResult) free_matrix(MatrixResult, Mb);  // Звільняємо пам'ять від попереднього результату, якщо він є
                MatrixResult = task_transpose_b(MatrixB, Nb, Mb);  // Транспонування матриці B
                printf("Matrix B transposed result:\n");
                print_matrix(MatrixResult, Mb, Nb, "B_Transposed");  // Виводимо транспоновану матрицю
                free_matrix(MatrixResult, Mb);  // Звільняємо пам'ять після використання
                MatrixResult = NULL;
                break;
            case 4:
                if (Na != Nb) {  // Перевірка умови для множення матриць
                    printf("Error: Matrix multiplication impossible! Cols of A (%d) != Rows of B (%d)\n", Na, Nb);
                } else {
                    if (MatrixResult) free_matrix(MatrixResult, Na);  // Звільняємо пам'ять попереднього результату
                    MatrixResult = task_multiply_matrices(MatrixA, Na, Na, MatrixB, Nb, Mb);  // Множимо матриці A і B
                    printf("Multiplication Result (A * B):\n");
                    print_matrix(MatrixResult, Na, Mb, "A*B");  // Виводимо результат множення
                    free_matrix(MatrixResult, Na);  // Звільняємо пам'ять після використання
                    MatrixResult = NULL;
                }
                break;
            case 5:
                task_sort_rows(MatrixA, Na, Na);  // Завдання 4: Сортування рядків матриці A
                printf("Matrix A after sorting rows:\n");
                print_matrix(MatrixA, Na, Na, "A");  // Виводимо матрицю A після сортування
                break;
            case 6:
                task_calc_sums(MatrixA, Na, Na, MatrixB, Nb, Mb);  // Завдання 5: Обчислення сум елементів
                break;
            case 0:
                printf("Exiting...\n");  // Вихід з програми
                break;
            default:
                printf("Invalid choice!\n");  // Помилка, якщо вибір некоректний
        }

    } while (choice != 0);  // Поки не вибрано 0 для виходу з програми

    // Звільнення пам'яті перед виходом
    free_matrix(MatrixA, Na);  // Звільняємо пам'ять для матриці A
    free_matrix(MatrixB, Nb);  // Звільняємо пам'ять для матриці B
    if (MatrixResult) free_matrix(MatrixResult, Na);  // Звільняємо пам'ять для результату, якщо він існує

    return 0;  // Завершення програми
}

// --- РЕАЛІЗАЦІЯ ФУНКЦІЙ ---

// Виділення пам'яті для двовимірного масиву (int**)
int** create_matrix(int rows, int cols) {
    int** matrix = (int**)malloc(rows * sizeof(int*));  // Виділяємо пам'ять для масиву рядків
    if (!matrix) return NULL;  // Якщо не вдалося виділити пам'ять для рядків, повертаємо NULL
    
    for (int i = 0; i < rows; i++) {
        matrix[i] = (int*)malloc(cols * sizeof(int));  // Виділяємо пам'ять для кожного рядка
        if (!matrix[i]) {  // Якщо не вдалося виділити пам'ять для рядка
            // Очищення пам'яті, якщо сталася помилка
            for (int j = 0; j < i; j++) free(matrix[j]);
            free(matrix);
            return NULL;
        }
    }
    return matrix;  // Повертаємо вказівник на створену матрицю
}

// Звільнення пам'яті
void free_matrix(int** matrix, int rows) {
    if (!matrix) return;  // Якщо матриця не існує, нічого не робимо
    for (int i = 0; i < rows; i++) {
        free(matrix[i]);  // Звільняємо пам'ять для кожного рядка
    }
    free(matrix);  // Звільняємо пам'ять для самого масиву рядків
}

// Заповнення випадковими числами
void fill_matrix_random(int** matrix, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = rand() % 100 - 20;  // Заповнюємо випадковими числами від -20 до 79
        }
    }
}

// Вивід матриці на екран
void print_matrix(int** matrix, int rows, int cols, const char* name) {
    printf("Matrix %s [%dx%d]:\n", name, rows, cols);  // Виводимо назву матриці та її розміри
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%5d ", matrix[i][j]);  // Виводимо елементи матриці з вирівнюванням
        }
        printf("\n");  // Перехід на новий рядок після виведення всіх елементів одного рядка
    }
}

// Завдання 1: Макс/Мін відносно діагоналі
void task_max_min_diagonal(int** A, int n_a, int variant) {
    int max_val, min_val;
    int first = 1; // прапор першого проходження

    printf("Variant %d -> ", variant);
    
    // Якщо варіант парний - нижче діагоналі (i > j)
    // Якщо непарний - вище діагоналі (i < j)
    int is_even = (variant % 2 == 0);
    
    if (is_even) printf("Searching BELOW main diagonal:\n");
    else printf("Searching ABOVE main diagonal:\n");

    for (int i = 0; i < n_a; i++) {
        for (int j = 0; j < n_a; j++) {
            int condition = is_even ? (i > j) : (i < j);
            
            if (condition) {
                if (first) {
                    max_val = min_val = A[i][j];
                    first = 0;
                } else {
                    if (A[i][j] > max_val) max_val = A[i][j];
                    if (A[i][j] < min_val) min_val = A[i][j];
                }
            }
        }
    }

    if (first) {
        printf("No elements found (matrix too small?)\n");
    } else {
        printf("Max: %d, Min: %d\n", max_val, min_val);
    }
}

// Завдання 2: Транспонування
int** task_transpose_b(int** B, int rows, int cols) {
    // Нова матриця має обернені розміри
    int** T = create_matrix(cols, rows);  // Створюємо нову матрицю для транспонованого результату
    
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            T[j][i] = B[i][j];  // Міняємо індекси місцями
        }
    }
    return T;  // Повертаємо транспоновану матрицю
}

// Завдання 3: Множення матриць
int** task_multiply_matrices(int** A, int rows_a, int cols_a, int** B, int rows_b, int cols_b) {
    // Результуюча матриця має розмір Rows_A x Cols_B
    int** C = create_matrix(rows_a, cols_b);  // Створюємо нову матрицю для результату множення
    
    for (int i = 0; i < rows_a; i++) {
        for (int j = 0; j < cols_b; j++) {
            C[i][j] = 0;
            for (int k = 0; k < cols_a; k++) {
                C[i][j] += A[i][k] * B[k][j];  // Обчислюємо елементи результату множення
            }
        }
    }
    return C;  // Повертаємо результат множення матриць
}

// Завдання 4: Сортування рядків бульбашкою
void task_sort_rows(int** A, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        // Сортуємо кожен рядок окремо
        for (int k = 0; k < cols - 1; k++) {
            for (int j = 0; j < cols - k - 1; j++) {
                if (A[i][j] > A[i][j + 1]) {
                    int temp = A[i][j];  // Обмін значеннями
                    A[i][j] = A[i][j + 1];
                    A[i][j + 1] = temp;
                }
            }
        }
    }
}

// Завдання 5: Суми рядків A та стовпців B
void task_calc_sums(int** A, int rows_a, int cols_a, int** B, int rows_b, int cols_b) {
    printf("\nSum of rows in Matrix A:\n");
    for (int i = 0; i < rows_a; i++) {
        int sum = 0;
        for (int j = 0; j < cols_a; j++) {
            sum += A[i][j];  // Обчислюємо суму кожного рядка матриці A
        }
        printf("Row %d: %d\n", i, sum);  // Виводимо суму рядка
    }

    printf("\nSum of columns in Matrix B:\n");
    for (int j = 0; j < cols_b; j++) {
        int sum = 0;
        for (int i = 0; i < rows_b; i++) {
            sum += B[i][j];  // Обчислюємо суму кожного стовпця матриці B
        }
        printf("Col %d: %d\n", j, sum);  // Виводимо суму стовпця
    }
}
