#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// --- ПРОТОТИПИ ФУНКЦІЙ ---

// Робота з пам'яттю
int** create_matrix(int rows, int cols);  
void free_matrix(int** matrix, int rows);  

// Заповнення та вивід
void fill_matrix_random(int** matrix, int rows, int cols);  
void fill_matrix_user(int** matrix, int rows, int cols);  
void print_matrix(int** matrix, int rows, int cols, const char* name);  


void task_max_min_diagonal(int** A, int n_a, int variant);  // Прототип для пошуку максимальних і мінімальних елементів відносно діагоналі
int** task_transpose_b(int** B, int rows, int cols);  // Прототип для транспонування матриці
int** task_multiply_matrices(int** A, int rows_a, int cols_a, int** B, int rows_b, int cols_b);  // Прототип для множення матриць
void task_sort_rows(int** A, int rows, int cols);  // Прототип для сортування рядків матриці
void task_calc_sums(int** A, int rows_a, int cols_a, int** B, int rows_b, int cols_b);  // Прототип для обчислення сум елементів

// --- ГОЛОВНА ФУНКЦІЯ ---
int main() {
    srand(time(NULL));  // Ініціалізація генератора випадкових чисел
    int **MatrixA = NULL;  
    int **MatrixB = NULL;  
    int **MatrixResult = NULL;  // Вказівник на результат виконання операцій
    
    int Na, Nb, Mb;  
    int variant;  
    int choice; 

    // Введення параметрів
    printf("Enter your variant number: ");
    scanf("%d", &variant);  /

    printf("Enter size for Matrix A (Na x Na): ");
    scanf("%d", &Na);  // квадратна матриця

    printf("Enter rows for Matrix B (Nb): ");
    scanf("%d", &Nb);  // кількість рядків 

    printf("Enter cols for Matrix B (Mb): ");
    scanf("%d", &Mb);  // кількість стовпців 

    // Виділення пам'яті
    MatrixA = create_matrix(Na, Na);  
    MatrixB = create_matrix(Nb, Mb);  

    if (!MatrixA || !MatrixB) {
        printf("Memory allocation failed!\n");
        return 1;  
    }

    
    printf("\n--- Filling Matrix A ---\n");
    fill_matrix_random(MatrixA, Na, Na);  
    
    printf("\n--- Filling Matrix B ---\n");
    fill_matrix_random(MatrixB, Nb, Mb); 

    // Головне меню
    do {
        printf("\n\n=== MENU ===\n");
        printf("1. Show Matrices\n");  
        printf("2. Find Max/Min relative to diagonal (Task 1)\n");  // Макс/мін відносно діагоналі
        printf("3. Transpose Matrix B (Task 2)\n");  // Транспонування
        printf("4. Multiply A * B (Task 3)\n");  // Множення матриць
        printf("5. Sort Matrix A rows (Task 4)\n");  // Сортування рядків матриці A
        printf("6. Calculate Sums (Task 5)\n");  // Суми рядків і стовпців
        printf("0. Exit\n");  
        printf("Choice: ");
        scanf("%d", &choice);  // Вводимо вибір операції

        switch (choice) {  
            case 1:
                print_matrix(MatrixA, Na, Na, "A");  
                print_matrix(MatrixB, Nb, Mb, "B"); 
                break;
            case 2:
                task_max_min_diagonal(MatrixA, Na, variant);  
                break;
            case 3:
                if (MatrixResult) free_matrix(MatrixResult, Mb);  
                MatrixResult = task_transpose_b(MatrixB, Nb, Mb);  
                printf("Matrix B transposed result:\n");
                print_matrix(MatrixResult, Mb, Nb, "B_Transposed");  
                free_matrix(MatrixResult, Mb);  
                MatrixResult = NULL;
                break;
            case 4:
                if (Na != Nb) {  // Перевірка умови для множення матриць
                    printf("Error: Matrix multiplication impossible! Cols of A (%d) != Rows of B (%d)\n", Na, Nb);
                } else {
                    if (MatrixResult) free_matrix(MatrixResult, Na);  // Звільняємо пам'ять попереднього результату
                    MatrixResult = task_multiply_matrices(MatrixA, Na, Na, MatrixB, Nb, Mb);  
                    printf("Multiplication Result (A * B):\n");
                    print_matrix(MatrixResult, Na, Mb, "A*B");  
                    free_matrix(MatrixResult, Na);  
                    MatrixResult = NULL;
                }
                break;
            case 5:
                task_sort_rows(MatrixA, Na, Na);  
                printf("Matrix A after sorting rows:\n");
                print_matrix(MatrixA, Na, Na, "A");  
                break;
            case 6:
                task_calc_sums(MatrixA, Na, Na, MatrixB, Nb, Mb);  
                break;
            case 0:
                printf("Exiting...\n");  
                break;
            default:
                printf("Invalid choice!\n"); 
        }

    } while (choice != 0); 

    free_matrix(MatrixA, Na); 
    free_matrix(MatrixB, Nb); 
    if (MatrixResult) free_matrix(MatrixResult, Na);  

    return 0; 
}

// --- РЕАЛІЗАЦІЯ ФУНКЦІЙ ---

// Виділення пам'яті для двовимірного масиву 
int** create_matrix(int rows, int cols) {
    int** matrix = (int**)malloc(rows * sizeof(int*));  
    if (!matrix) return NULL;  
    
    for (int i = 0; i < rows; i++) {
        matrix[i] = (int*)malloc(cols * sizeof(int));  
        if (!matrix[i]) {  
            for (int j = 0; j < i; j++) free(matrix[j]);
            free(matrix);
            return NULL;
        }
    }
    return matrix; // Повертаємо вказівник на матрицю
}

// Звільнення пам'яті
void free_matrix(int** matrix, int rows) {
    if (!matrix) return;  
    for (int i = 0; i < rows; i++) {
        free(matrix[i]); 
    }
    free(matrix);  
}

// Заповнення випадковими числами
void fill_matrix_random(int** matrix, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = rand() % 100 - 20;  // Заповнюємо випадковими числами від -20 до 79
        }
    }
}

// Вивід матриці на екран
void print_matrix(int** matrix, int rows, int cols, const char* name) {
    printf("Matrix %s [%dx%d]:\n", name, rows, cols);  
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%5d ", matrix[i][j]); 
        }
        printf("\n");  
    }
}

// Макс/Мін відносно діагоналі
void task_max_min_diagonal(int** A, int n_a, int variant) {
    int max_val, min_val;
    int first = 1; // прапор першого проходження

    printf("Variant %d -> ", variant);
    
    // Якщо варіант парний - нижче діагоналі (i > j)
    // Якщо непарний - вище діагоналі (i < j)
    int is_even = (variant % 2 == 0);
    
    if (is_even) printf("Searching BELOW main diagonal:\n");
    else printf("Searching ABOVE main diagonal:\n");

    for (int i = 0; i < n_a; i++) {
        for (int j = 0; j < n_a; j++) {
            int condition = is_even ? (i > j) : (i < j);
            
            if (condition) {
                if (first) {
                    max_val = min_val = A[i][j];
                    first = 0;
                } else {
                    if (A[i][j] > max_val) max_val = A[i][j];
                    if (A[i][j] < min_val) min_val = A[i][j];
                }
            }
        }
    }

    if (first) {
        printf("No elements found (matrix too small?)\n");
    } else {
        printf("Max: %d, Min: %d\n", max_val, min_val);
    }
}

// Транспонування
int** task_transpose_b(int** B, int rows, int cols) {
    int** T = create_matrix(cols, rows);  
    
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            T[j][i] = B[i][j];  // Міняємо індекси місцями
        }
    }
    return T;  // Повертаємо транспоновану матрицю
}

// Множення матриць
int** task_multiply_matrices(int** A, int rows_a, int cols_a, int** B, int rows_b, int cols_b) {
    int** C = create_matrix(rows_a, cols_b); 
    
    for (int i = 0; i < rows_a; i++) {
        for (int j = 0; j < cols_b; j++) {
            C[i][j] = 0;
            for (int k = 0; k < cols_a; k++) {
                C[i][j] += A[i][k] * B[k][j];  
            }
        }
    }
    return C;  // Повертаємо результат множення матриць
}

void task_sort_rows(int** A, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        // Сортуємо кожен рядок окремо
        for (int k = 0; k < cols - 1; k++) {
            for (int j = 0; j < cols - k - 1; j++) {
                if (A[i][j] > A[i][j + 1]) {
                    int temp = A[i][j];  // Обмін значеннями
                    A[i][j] = A[i][j + 1];
                    A[i][j + 1] = temp;
                }
            }
        }
    }
}

//  Суми рядків A та стовпців B
void task_calc_sums(int** A, int rows_a, int cols_a, int** B, int rows_b, int cols_b) {
    printf("\nSum of rows in Matrix A:\n");
    for (int i = 0; i < rows_a; i++) {
        int sum = 0;
        for (int j = 0; j < cols_a; j++) {
            sum += A[i][j];  // Обчислюємо суму кожного рядка матриці A
        }
        printf("Row %d: %d\n", i, sum);  // Виводимо суму рядка
    }

    printf("\nSum of columns in Matrix B:\n");
    for (int j = 0; j < cols_b; j++) {
        int sum = 0;
        for (int i = 0; i < rows_b; i++) {
            sum += B[i][j];  // Обчислюємо суму кожного стовпця матриці B
        }
        printf("Col %d: %d\n", j, sum);  // Виводимо суму стовпця
    }
}
